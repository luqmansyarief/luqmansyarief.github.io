<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer">

    <meta name="description" content="this site is Sirice's blog.">


    <meta name="keywords" content="Sirice, LiuZijian, Blog, CodeBlog">


<title>Java中线程同步的方法 | Sirice&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




    <!-- mathjax script -->
    
    
        
    




    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0d53ba8f0fba478a1a58df931ebcbec7";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
    

</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Sirice&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/collection">Collections</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Sirice&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/collection">Collections</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java中线程同步的方法</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Sirice</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 8, 2019&nbsp;&nbsp;12:17:54</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="一、同步方法"><a href="#一、同步方法" class="headerlink" title="一、同步方法"></a>一、同步方法</h3><p>　　即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
<p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<h3 id="二、同步代码块"><a href="#二、同步代码块" class="headerlink" title="二、同步代码块"></a>二、同步代码块</h3><p>　　即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</p>
<p>代码如：</p>
<pre><code class="java">synchronized(object){
}</code></pre>
<p> 注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可</p>
<pre><code class="java">package com.xhj.thread;

    /**
     * 线程同步的运用
     *
     * @author XIEHEJUN
     *
     */
    public class SynchronizedThread {

        class Bank {
            private int account = 100;
            public int getAccount() {
                return account;
            }

            /**
             * 用同步方法实现
             *
             * @param money
             */
            public synchronized void save(int money) {
                account += money;
            }

            /**
             * 用同步代码块实现
             *
             * @param money
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        }</code></pre>
<pre><code class="java">class NewThread implements Runnable {
            private Bank bank;

            public NewThread(Bank bank) {
                this.bank = bank;
            }

            @Override
            public void run() {
                for (int i = 0; i &lt; 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + &quot;账户余额为：&quot; + bank.getAccount());
                }
            }

        }

        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println(&quot;线程1&quot;);
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println(&quot;线程2&quot;);
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }

        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }

    }</code></pre>
<h4 id="synchronized同步方法小结："><a href="#synchronized同步方法小结：" class="headerlink" title="synchronized同步方法小结："></a>synchronized同步方法小结：</h4><p>给一个方法增加synchronized修饰符之后就可以使它成为同步方法，<u>这个方法可以是静态方法和非静态方法，但是不能是抽象类的抽象方法，也不能是接口中的接口方法。</u>下面代码是一个同步方法的示例：</p>
<pre><code class="java">public synchronized void aMethod() {
    // do something
}

public static synchronized void anotherMethod() {
    // do something
}</code></pre>
<h3 id="三、wait与notify"><a href="#三、wait与notify" class="headerlink" title="三、wait与notify"></a>三、wait与notify</h3><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<code>Object.wait()</code></p>
<p>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<code>Thread.sleep()</code></p>
<p>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</p>
<p>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h3 id="四、使用特殊域变量-volatile-实现线程同步"><a href="#四、使用特殊域变量-volatile-实现线程同步" class="headerlink" title="四、使用特殊域变量(volatile)实现线程同步"></a>四、使用特殊域变量(volatile)实现线程同步</h3><p>a. volatile关键字为域变量的访问提供了一种免锁机制</p>
<p>b. 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新</p>
<p>c. 因此每次使用该域就要重新计算，而不是使用寄存器中的值</p>
<p>d. volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</p>
<p>例如：在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。</p>
<pre><code class="java">//只给出要修改的代码，其余代码与上同
        class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;

            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                account += money;
            }
        ｝</code></pre>
<h3 id="五、使用重入锁实现线程同步"><a href="#五、使用重入锁实现线程同步" class="headerlink" title="五、使用重入锁实现线程同步"></a>五、使用重入锁实现线程同步</h3><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。</p>
<p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。</p>
<p>ReenreantLock类的常用方法有：</p>
<pre><code>ReentrantLock() // 创建一个ReentrantLock实例
lock() // 获得锁
unlock() // 释放锁</code></pre><p><em>注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用</em></p>
<pre><code class="java">//只给出要修改的代码，其余代码与上同
        class Bank {

            private int account = 100;
            //需要声明这个锁
            private Lock lock = new ReentrantLock();
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized
            public void save(int money) {
                lock.lock();
                try{
                    account += money;
                }finally{
                    lock.unlock();
                }

            }
        ｝</code></pre>
<p>注：关于Lock对象和synchronized关键字的选择：</p>
<p>a. 最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。</p>
<p>b. 如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码</p>
<p>c. 如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁</p>
<h3 id="六、使用阻塞队列实现线程同步"><a href="#六、使用阻塞队列实现线程同步" class="headerlink" title="六、使用阻塞队列实现线程同步"></a>六、使用阻塞队列实现线程同步</h3><p>前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。</p>
<p>本小节主要是使用LinkedBlockingQueue<e>来实现线程的同步 LinkedBlockingQueue<e>是一个基于已连接节点的，范围任意的blocking queue。</e></e></p>
<p>LinkedBlockingQueue 类常用方法</p>
<pre><code>LinkedBlockingQueue() // 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue
put(E e) // 在队尾添加一个元素，如果队列满则阻塞
size() // 返回队列中的元素个数
take() // 移除并返回队头元素，如果队列空则阻塞</code></pre><p>注：BlockingQueue<e>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：</e></p>
<pre><code>add()方法会抛出异常
offer()方法返回false
put()方法会阻塞</code></pre><h3 id="七、使用原子变量实现线程同步"><a href="#七、使用原子变量实现线程同步" class="headerlink" title="七、使用原子变量实现线程同步"></a>七、使用原子变量实现线程同步</h3><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。</p>
<p>那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p>
<p>AtomicInteger类常用方法：</p>
<pre><code>AtomicInteger(int initialValue) // 创建具有给定初始值的新的
AtomicIntegeraddAddGet(int dalta) // 以原子方式将给定值与当前值相加
get() // 获取当前值</code></pre><p>补充：原子操作主要有：　　</p>
<ol>
<li><p>对于引用变量和大多数原始变量(long和double除外)的读写操作；　　</p>
</li>
<li><p>对于所有使用volatile修饰的变量(包括long和double)的读写操作。</p>
</li>
</ol>
<p>实例：</p>
<pre><code class="java">class Bank {
    private AtomicInteger account = new AtomicInteger(100);
    public AtomicInteger getAccount() {
        return account;
    }
    public void save(int money) {
        account.addAndGet(money);
    }
}</code></pre>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Sirice</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://siricee.github.io/2019/03/08/java-thread-synchronized/">https://siricee.github.io/2019/03/08/java-thread-synchronized/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>本文采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享 署名-非商业性使用-禁止演绎(CC BY-NC-ND)国际许可协议</a>进行许可</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/java/"># java</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/03/11/java-static-keyword/">Java static关键字</a>
            
            
            <a class="next" rel="next" href="/2019/03/02/cmbnt-interview-2019Autumn/">招商银行2019秋招后端笔试算法题记录</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Sirice | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
    
        <script type="text/javascript" color="0,0,0" opacity="0.3" zindex="-2" count="99" src="/js/canvas-nest.js"></script>
    
</body>
</html>
